class GameCycle{
    field int blockMovementPeriod;
    field int blockMovementTicks;
    //field int blockDelay;
    field int newBlockPeriod;
    field int newBlockTicks;
    field int keyboardCheckPeriod;  //in ticks
    field int keyboardCheckTicks;
    field int keyboardCheckSuccessCount;
    //how unoften we take truly random things from outside to make game more random
    field int randomizingRarity; //in number of successful keyboardCheckPeriods
    field int randKey;

    field int timeTicks;

    field int standartTickDelay;
    field int screenWidth;
    field int screenHeigth;
    field int score;

    field int bonusBlockRarity; // > 0, the higher the rarer

    //output strings
    field String scoreStr;
    field String timeStr;
    field String pauseMessage;
    field String endGameMessage;
    field String restartMessage;
    
    //field int bitmask;
    
    field UnrandomizerSimple unrandom;
    field LCGenerator random;
    field Array blockArr;
    field Player player;
    field PlayerMovement playerMove;
    field Point playerCoordinatesInArr;

    field int blockWidth;
    field int blockHeight;

    //blockType
    field int standartBlockStyleType;
    field int bonusBlockStyleType;

    constructor GameCycle new(Settings sets){
        var int i, j;
        //var int maxPlayerJumpHeight;//
        var Array bufferArr;
        //let bitmask = 15872; //0001111100000???
        //let blockDelay = 0;
        let blockMovementPeriod = sets.getBlockMovementPeriod();
        let blockMovementTicks = 0;
        let standartTickDelay = sets.getStandartTickDelay();
        let blockWidth = 32; //51
        let blockHeight = 32; //42
        let screenWidth = 512 / blockWidth;
        let screenHeigth = 256 / blockHeight;
        //let gameIsNotFinished = true;
        let newBlockPeriod = sets.getNewBlockPeriod();
        let newBlockTicks = 0;

        let bonusBlockRarity = sets.getBonusBlockRarity();

        let keyboardCheckPeriod = 50;
        let keyboardCheckTicks = 0;
        let keyboardCheckSuccessCount = 0;
        let randomizingRarity = 7;
        let timeTicks = 0;

        let score = 0;
        
        let blockArr = Array.new(screenHeigth);

        let scoreStr = "score: ";
        let timeStr = " time: ";
        let pauseMessage = "game is paused; to continue press [p]";
        let endGameMessage = "you are dead :(  ";
        let restartMessage = "to restart press any key";

        //let maxPlayerJumpHeight = 145;
        let player = Player.new(0, 0, 30, 20, sets.getPlayerHorizontalSpeed(), sets.getPlayerJumpSpeed(), sets.getPlayerFallSpeed());
        let playerMove = PlayerMovement.new(player, blockArr, blockHeight, blockWidth, sets.getMaxPlayerJumpHeight());

        let standartBlockStyleType = sets.getStandartBlockStyleType();
        let bonusBlockStyleType = sets.getBonusBlockStyleType();

        let i = 0;
        while (i < (screenHeigth)){
            let bufferArr = Array.new(screenWidth);
            let blockArr[i] = bufferArr;
            let j = 0;
            while (j < screenWidth){
                let bufferArr[j] = 0;
                let j = j + 1;
            }
            let i = i + 1;
        }
        
        let randKey = 7394;
        let random = LCGenerator.new(randKey);
        let unrandom = UnrandomizerSimple.new(1, random, screenWidth, screenHeigth);
        return this;
    }

    method void game(){
        var Array upRow, downRow;
        var int rowNum, columnNum;
        var Block blockBuffer;
        var bool isRowComplete;
        var int randomBlockPos;
        var int key; //yap it is int
        var int iterator;
        var int blockTypeDecider;
        var Point playerCoords;
        var bool gameIsNotFinished;
        let gameIsNotFinished = true;
        while (gameIsNotFinished){
            //try move blocks
            if (blockMovementTicks > blockMovementPeriod){
                let blockMovementTicks = 0;
                let rowNum = screenHeigth - 2;
                let downRow = blockArr[screenHeigth - 1];
                //check if blocks can fall
                while (rowNum > -1){
                    let upRow = blockArr[rowNum];
                    let columnNum = screenWidth - 1;
                    //move blocks
                    while (columnNum > -1){
                        if (~(upRow[columnNum] = 0)){
                            if (downRow[columnNum] = 0){
                                let blockBuffer = upRow[columnNum];
                                let upRow[columnNum] = 0;
                                let downRow[columnNum] = blockBuffer;
                                do blockBuffer.erase();
                                do blockBuffer.moveDown();
                                do blockBuffer.draw();
                            }
                        }
                        let columnNum = columnNum - 1;
                    }
                    //check down row completeness and erase if so
                    let columnNum = 0;
                    let isRowComplete = true;
                    while (columnNum < screenWidth){
                        if (downRow[columnNum] = 0){
                            let isRowComplete = false;
                        }
                        let columnNum = columnNum + 1;
                    }
                    if (isRowComplete){
                        let columnNum = 0;
                        while (columnNum < screenWidth){
                            let blockBuffer = downRow[columnNum];
                            let downRow[columnNum] = 0;
                            do blockBuffer.erase();
                            do blockBuffer.dispose();
                            let columnNum = columnNum + 1;
                        }
                        do unrandom.correctForDeletedRow();
                    }

                    let downRow = upRow;
                    let rowNum = rowNum - 1;
                }
                do showScore();
            }
            //add random block
            if (newBlockTicks > newBlockPeriod){
                //try add new blocks
                let randomBlockPos = unrandom.computeNextPos();
                let upRow = blockArr[0];
                if (randomBlockPos > -1){
                    if (upRow[randomBlockPos] = 0){
                        //deside on blocktype
                        let blockTypeDecider = (random.nextInt() & 32767) / 512;
                        let blockTypeDecider = blockTypeDecider 
                                    - (bonusBlockRarity * (blockTypeDecider / bonusBlockRarity));
                        if (blockTypeDecider = 0){
                            let blockBuffer = Block.new(blockWidth * randomBlockPos,
                                     0, blockHeight, blockWidth, 1, bonusBlockStyleType);
                        }else{
                            let blockBuffer = Block.new(blockWidth * randomBlockPos,
                                     0, blockHeight, blockWidth, 0, standartBlockStyleType);
                        }
                        
                        let upRow[randomBlockPos] = blockBuffer;
                        do blockBuffer.draw();
                        do unrandom.correctForNewBlock(randomBlockPos);
                    }
                    let newBlockTicks = 0;
                    //output current score
                    do showScore();
                }
            }
            //try move player
            do playerMove.execute();

            //check for player-block collision
            let playerCoordinatesInArr = playerMove.getPlayerArrCoordinates();
            let upRow = blockArr[playerCoordinatesInArr.getY()];
            let blockBuffer = upRow[playerCoordinatesInArr.getX()];
            if (~(blockBuffer = 0)){
                if (blockBuffer.getType() = 0){
                    let gameIsNotFinished = false;
                }else{
                    do blockBuffer.erase();
                    do blockBuffer.dispose();
                    let upRow[playerCoordinatesInArr.getX()] = 0;
                    do unrandom.correctForCollectedBlock(playerCoordinatesInArr.getX());
                    let score = score + 1;
                    do showScore();
                    do player.draw();
                }
            }
            
            //take input for pause and exit
            let key = Keyboard.keyPressed();
            if (key = 80){      //p - pause
                do Sys.wait(200);
                do Output.moveCursor(10, 15);
                do Output.printString(pauseMessage);
                while((~(Keyboard.keyPressed() = 80)) & (~(Keyboard.keyPressed() = 140))){
                    do Sys.wait(1);
                }
                let key = Keyboard.keyPressed();
                do Sys.wait(200);
            }
            if (key = 140){     //esc
                let gameIsNotFinished = false;
            }
            //take randomness from the outside world
            if (keyboardCheckTicks > keyboardCheckPeriod){
                //let key = Keyboard.keyPressed();
                if (~(key = 0)){
                    let keyboardCheckSuccessCount = keyboardCheckSuccessCount + 1;
                    if (keyboardCheckSuccessCount > randomizingRarity){
                        //old random is disposed in unrandom
                        let randKey = (timeTicks + key) & 32767;
                        let random = LCGenerator.new(randKey);
                        do unrandom.setLCG(random);
                        let keyboardCheckSuccessCount = 0;
                    }
                }
                let keyboardCheckTicks = 0;
            }

            //move timers
            let blockMovementTicks = blockMovementTicks + 1;
            let newBlockTicks = newBlockTicks + 1;
            let keyboardCheckTicks = keyboardCheckTicks + 1;
            let timeTicks = timeTicks + 1;
            
            //controle the time flow
            do Sys.wait(standartTickDelay);
        }

        //player is dead here or game is stopped
        //anyway
        let iterator = 0;
        while (iterator < 100){
            //bad output ;)
            do Output.printString(endGameMessage);
            let iterator = iterator + 1;
        }
        do MainMenu.window(50, 100, 460, 130);
        do Output.moveCursor(10, 15);
        do Output.printString(scoreStr);
        do Output.printInt(score);
        do Output.moveCursor(10, 36);
        do Output.printString(timeStr);
        do Output.printInt(timeTicks);

        do MainMenu.window(50, 200, 460, 230);
        do Output.moveCursor(19, 20);
        do Output.printString(restartMessage);

        //dispose something? nope
        return;
    }

    method void showScore(){
        do Output.moveCursor(0, 0);
        do Output.printString(scoreStr);
        do Output.printInt(score);
        do Output.printString(timeStr);
        do Output.printInt(timeTicks);
        return;
    }

    method void dispose(){
        var int i;
        var Array a;
        let i = 0;
        while (i < screenHeigth){
            let a = blockArr[i];
            do a.dispose();
            let i = i + 1;
        }
        do blockArr.dispose();
        do player.dispose();
        do unrandom.dispose();
        //do random.dispose();  //disposed in unrandom
        do playerMove.dispose();
        do scoreStr.dispose();
        do timeStr.dispose();
        do pauseMessage.dispose();
        do endGameMessage.dispose();
        do restartMessage.dispose();
        do Memory.deAlloc(this);
        return;
    }
}