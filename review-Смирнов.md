# MainMenu
Очень круто, что вы реализовали меню, с возможностью настроить игру под себя.
- MainMenu.ShowMenu(...)
    1) Тут имеется небольшая проблема: из любого подменю можно зайти в любое другое. Это несколько сбивает с толку. Хорошо было бы если был бы какой-то флаг, который позволял бы понимать находимся ли мы в каком-то подменю, чтобы заблокировать произвольный переход (например из меню по клавише d в меню по клавише q).
    2) Было бы круто, если бы вы не захардкодили клавиши в коде "if (key = 81)", а записали бы их значения в константы.

# Settings
Ну здесь вообще все замечательно на мой взгляд. Единственное - это наверное то, что не во всех сеттерах есть проверка на "адекватность" аргумента, но, наверное это не важно в этих сеттерах.

# GameCycle
Все работает как часы. Код достаточно понятен, но выбор названий некторых переменных, например gameIsNotFinished в некоторых методах выглядит очень странно на мой взгляд. Лучше переименовать в gameIsFinished. Куча сложной логики в одном классе: здесь блоки и создаются, и двигаются, и проверяются коллизии блока с игроком. Я бы выделил класс, который создаёт блоки ("фабрику блоков" aka кирпичный завод), модель в которой все хранится и обрабатывается, и презентатор, который бы выводил всю сцену на экран.
В коде, для каждого пикселя мы храним блок, который лежит на нем. Непонятно почему не хранить массив блоков с их позцииями и размерами.
В целом  предлага разделить этот класс как я сказал ранее, чтобы разделить ответственность.
Далее по методам:
- processPlayerBlockCollisions()
    Здесь создаётся переменная gameIsNotFinished но нигде не используется.
- game()
    1) Название метода не глагол, выглядит непривычно
    2) ```
        if (~processPlayerBlockCollisions()){
            let gameIsNotFinished = false;
        }
        ```
        Лучше написать
        ```
        let gameIsNotFinished = processPlayerBlockCollisions();
        ```
        или
        let gameIsFinished = ~processPlayerBlockCollisions();
- processPlayerBlockCollisions
    Кнчн понятно, что делает метод, но неясно почему он возврщает bool. Предлагаю назвать метод IsPlayerBlockCollisionsAppeared() или что то в этом духе.
- moveBlocks()
    1) Сигнатура метода съехала
    2) Вынести бы в презентатор какой-нибудь.
        ```
        do blockBuffer.draw();
        ```
        На мой взгляд, как я писал раньше, лучше разделить модель и её представление. В остальных методах есть такие же строки, про них я писать повторно не хочу, но считаю точно также.
- tryAddNewBlock()
    Вот здесь бы и пригодился кирпичный завод. Не пришлось бы писать эти if-ы.
    ```
    let blockTypeDecider = (random.nextInt() & 32767) / 512;
    let blockTypeDecider = blockTypeDecider 
                - (bonusBlockRarity * (blockTypeDecider / bonusBlockRarity));
    if (blockTypeDecider = 0){
        //bonus block
        let blockBuffer = Block.new(blockWidth * randomBlockPos,
                    0, blockHeight, blockWidth, 1, bonusBlockStyleType);
    }else{
        //standart block
        let blockBuffer = Block.new(blockWidth * randomBlockPos,
                    0, blockHeight, blockWidth, 0, standartBlockStyleType);
    }
    ```
-  showDeathScreen()
    Вынести в презентатор
    
# PlayerMovement
Все классно, только бы метод execute разбить на вспомогательные, вроеж Jump, Move и т. д. Ну и не хардкодить кнопки передвижения. Ну и название странное, типо, что такое execute? Я бы назвал MovePlayer или что то вроде того.
    
# LCGenerator
Очень круто, что вы реализовали генератор псевдослучайных чисел. А больше и сказать нечего, все классно здесь.

# Point
Точка - это точка, точка - это круто!

# UnrandomizerSimple
Хорошо, что вы позаботились о том, чтобы блоки падали адекватно, а не полностью рандомно, ведь играть в "нечестную" игру никто бы не заходил. 

# Player
В общем, как я раньше писал, стоит выделить презентатор. Отрисовка сущности, на мой взгляд, - не ответственность самой сущности. Рисовать должен отдельный класс - презентатор, которому передаются только данные, необходимые для отображения модели. Проще говоря, рисовать игрока - не ответственность игрока.

# Block
Опять же, рисовать блок - не ответственность блока. А с разными типами блоков очень интересно придумано. И наверное было бы круто создать класс стиля блока, который бы просто хранил данные для отрисовки, его вместе с позицией блока скармливать презентатору, а он бы в свою очередь выводил.

В общем то и всё, я пробежался по всему коду. 
В заключение, хочу сказать, что несмотря на все замечания, что я написал выше, проект мне показался по-настаящему выдающимся. Очень классная идея и не меняя классная реализация. Прочитав код, я понял, насколько много сил было вложено в этот проект и это очень впечатляет. Очень круто)



